import networkx as net
import random
from read_dag import read_dag
import operator
from math import isclose
import numpy as np

# Soulmaz

class Task:
    def __init__(self, id):
        self.id = id
        self.processor_id = None
        self.rank = None
        self.comp_cost = []
        self.avg_comp = None
        self.duration = {'start':None, 'end':None}

class Processor:
    def __init__(self, id):
        self.id = id
        self.task_list = []

class LADA:
    def __init__(self, input_list=None, file=None, verbose=False, p=3, b=0.5, ccr=0.5):
        if input_list is None and file is not None:
            self.num_tasks, self.num_processors, comp_cost, self.graph = read_dag(file, p, b, ccr)
        elif len(input_list) == 4 and file is None:
            self.num_tasks, self.num_processors, comp_cost, self.graph = input_list
        else:
            print('Enter filename or input params')
            raise Exception()

        if verbose:
            print("No. of Tasks: ", self.num_tasks)
            print("No. of processors: ", self.num_processors)
            print("Computational Cost Matrix:")
            for i in range(self.num_tasks):
                print(comp_cost[i])
            print("Graph Matrix:")
            for line in self.graph:
                print(line)
        
        self.tasks = [Task(i) for i in range(self.num_tasks)]
        self.processors = [Processor(i) for i in range(self.num_processors)]

        for i in range(self.num_tasks):
            self.tasks[i].comp_cost = comp_cost[i]
            self.tasks[i].avg_comp = sum(comp_cost[i]) / self.num_processors
        
        self.__computeRanks(self.tasks[0])
        
        self.LADAgrouping (self.graph, self.iterations, self.root_node, self.final_node)
        # self.__allotProcessor()
        self.makespan = max([t.duration['end'] for t in self.tasks])

    def __computeRanks(self, task):
        # Assume that task[0] is the initial task, as generated by TGFF
        # Assume communicate rate is equal between processors
        curr_rank = 0
        for succ in self.tasks:
            if self.graph[task.id][succ.id] != -1:
                if succ.rank is None:
                    self.__computeRanks(succ)
                curr_rank = max(curr_rank, self.graph[task.id][succ.id] + succ.rank)
        task.rank = task.avg_comp + curr_rank
    
    def __get_est(self, node, processor):
        est = 0
        for pre in self.tasks:
            if self.graph[pre.id][node.id] != -1:  # if pre also done on processor, no communication cost
                c = self.graph[pre.id][node.id] if pre.processor_id != processor.id else 0
                est = max(est, pre.duration['end'] + c)
        free_times = []
        if len(processor.task_list) == 0:       # no task has yet been assigned to processor
            free_times.append([0, float('inf')])
        else:
            for i in range(len(processor.task_list)):
                if i == 0:
                    if processor.task_list[i].duration['start'] != 0:    # if p is not busy from time 0
                        free_times.append([0, processor.task_list[i].duration['start']])
                else:
                    free_times.append([processor.task_list[i-1].duration['end'], processor.task_list[i].duration['start']])
            free_times.append([processor.task_list[-1].duration['end'], float('inf')])
        for slot in free_times:     # free_times is already sorted based on avaialbe start times
            if est < slot[0] and slot[0] + node.comp_cost[processor.id] <= slot[1]:
                return slot[0]
            if est >= slot[0] and est + node.comp_cost[processor.id] <= slot[1]:
                return est


    def LADAgrouping (self, graph, iterations, root_node, final_node):
    
        ## reward and penalty parameters
        a = 0.009
        b = 0.00009
        R = 5

        total_neighbors = set()
        for node in graph:
            total_neighbors = total_neighbors.union(net.neighbors(graph, node))

        ## Phase 1: Constructing network of LA Isomorphic to independent taskes grouped DAG
        
        group = dict()
        i = 1
        for node in graph:
            while len(list(graph.neighbors(node))) == i:
                group[i].append(node)
            i = i + 1
        
        Automatas = dict()
        action_set = dict()
        action_prob = dict()
        W_i = dict()
        reward = dict()
        G_i = 1
        for j in G_i:
            for node in group[G_i]:
                Automatas[node] = 0
                action_set[node] = list(self.processors)
                action_prob[node] = 1/len(self.processors)
                W_i[node] = 0
                reward[node] = 0

        k_n = sum(action_prob.values())

        ## Phase 2: task assaignment

        k = 0
        while k <  iterations:
            j = 1
            while j < i + 1:
                for nodes in group[j]:
                    if nodes == root_node: #self.tasks[0], the one with highest rank
                        p, w = min(enumerate(nodes.comp_cost), key=operator.itemgetter(1))
                        nodes.processor_id = p
                        nodes.duration['start'] = 0
                        nodes.duration['end'] = w
                        self.processors[p].task_list.append(nodes)
                        
                    else:
                        aft = float("inf")
                        for p in self.processors:
                            est = self.__get_est(nodes, p)
                            eft = est + nodes.comp_cost[p.id]
                            if eft < aft:   # found better case of processor
                                aft = eft
                                best_p = p.id
                
                        nodes.processor_id = best_p
                        if action_set.keys ==  best_p:
                            v_k = action_set.values 
                        nodes.duration['start'] = aft - nodes.comp_cost[best_p]
                        nodes.duration['end'] = aft
                        self.processors[best_p].task_list.append(nodes)
                        self.processors[best_p].task_list.sort(key = lambda x: x.duration['start'])
                j = j + 1        
            best = 0
            if k == 0:
                self.makespan[best]=self.makespan[k]

            self.makespan[k] = max([t.duration['end'] for t in self.tasks])
            if self.makespan[k]<self.makespan[best]: #reward
                self.makespan[best]=self.makespan[k]
                for n in action_set:
                    reward[n] = reward[n] + a
                    action_prob[n] = action_prob[n] + a*(1-action_prob[n])
                    if n!=v_k: #j!=i
                        action_prob[n] = (1-a) * action_prob[n]
            else:
                for n in action_set:   #Penalty
                    reward[n] = reward[n] - b
                    action_prob[n] = (1-b) * action_prob[n]
                    if n!=v_k: #j!=i
                        action_prob[n] = (b/(reward[n]-1)) + (1-b) * action_prob[n]
                
            k_n = sum(action_prob.values())
            for p in action_prob:
                action_prob[p] = action_prob[p]/k_n
            
            k = k + 1

    def __str__(self):
        print_str = ""
        for p in self.processors:
            print_str += 'Processor {}:\n '.format(p.id)
            for t in p.task_list:
                print_str += 'Task {}: start = {}, end = {}\n'.format(t.id+1, t.duration['start'], t.duration['end'])
        print_str += "Makespan = {}\n".format(self.makespan)
        return print_str

if __name__ == "__main__":
    from argparse import ArgumentParser
    ap = ArgumentParser()
    ap.add_argument('-i','--input', required=True, help="DAG description as a .dot file")
    args = ap.parse_args()
    new_sch = LADA(file=args.input, verbose=True, p=4, b=0.1, ccr=0.1)
    print(new_sch)